#include <math.h>
#include <string.h>
#include "igrf.h"
#include "igrf_data.h" // Auto-generated by MATLAB tools/generate_c_header.m

// Constants
#define RE_A 6378137.0f // WGS84 Semi-major axis
#define FLATTENING (1.0f / 298.257223563f)
#define GEOMAG_R 6371200.0f // Geomagnetic Reference Radius
#define BASE_YEAR 2025.0f   // IGRF-14 Epoch
#define DEG2RAD 0.0174532925f
#define PI 3.1415926535f

// Helper Functions

// Compute Knm recursion coefficients (Same as MATLAB compute_Snm_Knm)
static void compute_knm(float K[IGRF_DIM][IGRF_DIM])
{
    for (int n = 1; n <= IGRF_N; n++)
    {
        for (int m = 0; m <= n; m++)
        {
            if (n == 1)
            {
                K[n][m] = 0.0f;
            }
            else
            {
                float num = (float)((n - 1) * (n - 1) - m * m);
                float den = (float)((2 * n - 1) * (2 * n - 3));
                K[n][m] = num / den;
            }
        }
    }
}

// Compute Schmidt Normalization Factors (Snm)
static void compute_snm(float S[IGRF_DIM][IGRF_DIM])
{

    // Reset
    memset(S, 0, sizeof(float) * IGRF_DIM * IGRF_DIM);
    S[0][0] = 1.0f;

    for (int n = 1; n <= IGRF_N; n++)
    {
        S[n][0] = S[n - 1][0] * (float)(2 * n - 1) / (float)n;
        for (int m = 1; m <= n; m++)
        {
            float J = (m == 1) ? 2.0f : 1.0f;
            S[n][m] = S[n][m - 1] * sqrtf((float)((n - m + 1) * J) / (float)(n + m));
        }
    }
}

// Main Compute Function
void igrf_compute(const igrf_input_t *in, igrf_output_t *out)
{

    // Geodetic -> Geocentric
    float lat_rad = in->lat_deg * DEG2RAD;
    float lon_rad = in->lon_deg * DEG2RAD;
    float sin_lat = sinf(lat_rad);
    float cos_lat = cosf(lat_rad);

    float e2 = FLATTENING * (2.0f - FLATTENING);
    float Rc = RE_A / sqrtf(1.0f - e2 * sin_lat * sin_lat);

    float p = (Rc + in->alt_m) * cos_lat;
    float z = (Rc * (1.0f - e2) + in->alt_m) * sin_lat;
    float r = sqrtf(p * p + z * z);

    float lat_c = asinf(z / r);
    float theta = PI / 2 - lat_c; // Colatitude (90 - lat_geo)
    float epsilon = lat_rad - lat_c;

    // Gaussian Coefficients
    float dt = in->year - BASE_YEAR;
    float g[IGRF_DIM][IGRF_DIM];
    float h[IGRF_DIM][IGRF_DIM];
    float S[IGRF_DIM][IGRF_DIM];

    // Computation Normalization factors
    compute_snm(S);

    // Unpack + Secular Variation + Un-normalization
    for (int m = 0; m < IGRF_DIM; m++)
    {
        for (int n = 0; n < IGRF_DIM; n++)
        {

            int idx = n + m * IGRF_DIM;

            float g_schmidt = g_coeff[idx] + dt * g_sv[idx];
            float h_schmidt = h_coeff[idx] + dt * h_sv[idx];

            // Un-normalization
            g[n][m] = g_schmidt * S[n][m];
            h[n][m] = h_schmidt * S[n][m];
        }
    }

    // Computation Legendre Polynomials
    float P[IGRF_DIM][IGRF_DIM];
    float dP[IGRF_DIM][IGRF_DIM];
    float K[IGRF_DIM][IGRF_DIM];

    memset(P, 0, sizeof(P));
    memset(dP, 0, sizeof(dP));
    compute_knm(K);

    P[0][0] = 1.0f;
    float c_tt = cosf(theta);
    float s_tt = sinf(theta);

    for (int n = 1; n <= IGRF_N; n++)
    {
        for (int m = 0; m <= n; m++)
        {
            if (m == n)
            {
                P[n][m] = s_tt * P[n - 1][m - 1];
                dP[n][m] = s_tt * dP[n - 1][m - 1] + c_tt * P[n - 1][m - 1];
            }
            else if (m == n - 1)
            {
                P[n][m] = c_tt * P[n - 1][m];
                dP[n][m] = c_tt * dP[n - 1][m] - s_tt * P[n - 1][m];
            }
            else
            {
                float k_val = K[n][m];
                P[n][m] = c_tt * P[n - 1][m] - k_val * P[n - 2][m];
                dP[n][m] = c_tt * dP[n - 1][m] - s_tt * P[n - 1][m] - k_val * dP[n - 2][m];
            }
        }
    }

    // Summation
    float sumR = 0.0f, sumT = 0.0f, sumL = 0.0f;
    float r_ratio = GEOMAG_R / r;
    float scale = r_ratio * r_ratio; // (a/r)^2

    for (int n = 1; n <= IGRF_N; n++)
    {
        scale *= r_ratio; // (a/r)^(n+2)

        for (int m = 0; m <= n; m++)
        {
            float cos_mlon = cosf(m * lon_rad);
            float sin_mlon = sinf(m * lon_rad);

            float g_val = g[n][m];
            float h_val = h[n][m];
            float p_val = P[n][m];
            float dp_val = dP[n][m];

            float term_cos = g_val * cos_mlon + h_val * sin_mlon;
            float term_sin = -g_val * sin_mlon + h_val * cos_mlon;

            sumR += scale * (n + 1) * p_val * term_cos;
            sumT += scale * dp_val * term_cos;
            sumL += scale * m * p_val * term_sin;
        }
    }

    // Vector recovery
    float Br = sumR;
    float Bt = -sumT;
    float Bl = 0.0f;

    // Singularity check
    // Physics breaks here, so we force it to 0.
    if (fabsf(s_tt) > 1e-5f)
    {
        Bl = -sumL / s_tt;
    }

    // Rotate Geocentric to NED
    float c_eps = cosf(epsilon);
    float s_eps = sinf(epsilon);

    out->B_north = -Bt * c_eps - Br * s_eps;
    out->B_east = Bl;
    out->B_down = Bt * s_eps - Br * c_eps;
    out->F_total = sqrtf(out->B_north * out->B_north + out->B_east * out->B_east + out->B_down * out->B_down);
}